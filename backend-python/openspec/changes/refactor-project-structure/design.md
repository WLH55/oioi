## Context

当前项目存在以下问题，需要重构：

**1. 项目结构问题**
采用传统的按文件类型划分的项目结构：
- `app/api/routes/` - 所有路由文件
- `app/models/` - 所有数据库模型
- `app/schemas/` - 所有 Pydantic schemas
- `app/services/` - 所有服务层代码
- `app/core/` - 核心配置
- `app/utils/` - 工具函数

这种结构导致：
- 开发者需要在多个目录间切换来完成一个功能的修改
- 模块边界不清晰，容易产生跨模块的隐式依赖
- 新成员难以理解代码组织方式
- 测试代码组织不清晰

**2. API 响应格式问题**
- 缺少统一的响应格式规范
- 不同接口返回格式不一致
- 错误处理方式不统一
- 缺少标准化的响应码管理

**3. 路由定义问题**
- HTTP 方法使用不一致（混用 GET/POST/PUT/DELETE）
- 路由命名不规范
- 缺少统一的文档标准
- 参数验证方式不统一

**约束条件：**
- 项目已经在线上运行
- API 响应格式改变将影响前端调用
- 需要支持 SQLite 和 PostgreSQL 两种数据库
- 已有测试需要在新结构下继续工作

**利益相关者：**
- 开发团队：需要清晰的代码组织以提高开发效率
- 前端团队：需要统一的 API 接口规范
- 运维团队：需要清晰的部署结构
- API 消费者：需要稳定且一致的 API 接口

## Goals / Non-Goals

**Goals:**
- 重构为按业务领域模块划分的目录结构（Netflix Dispatch 风格）
- 每个模块包含其相关的所有代码文件
- 建立清晰的模块边界和依赖关系
- 改进测试组织和测试基础设施
- 分离配置按模块和环境
- 建立可扩展的依赖注入模式
- **统一 API 响应格式（ApiResponse）**
- **标准化路由方法（仅使用 GET/POST）和命名**
- **建立统一的异常处理机制**
- **完善 API 文档标准**

**Non-Goals:**
- **API 响应格式将改变，这是有意的破坏性变更**
- 不修改业务逻辑（仅重组代码位置和调整响应格式）
- 不添加新功能
- 不改变数据库结构
- 不立即引入复杂的依赖注入框架（使用 FastAPI 内置依赖系统）

## Decisions

### 决策 1：使用 `src/` 目录而非根目录

**选择：** 将所有应用代码放在 `src/` 目录下

**理由：**
- 区分应用代码和配置文件
- 便于打包和分发
- 行业标准做法（大多数现代 Python 项目采用此结构）
- 更清晰地标识"这是源代码"

**替代方案：**
- 根目录直接放置模块代码：会使项目根目录混乱，不易区分配置和代码

### 决策 2：按业务领域划分模块

**选择：** 每个 API 资源（dramas, episodes, tasks 等）成为一个独立的模块目录

**理由：**
- 相关代码聚合在一起，便于理解和维护
- 模块边界清晰，减少耦合
- 支持团队按模块分工
- 符合单一职责原则

**模块识别：**
根据现有路由，识别出以下模块：
1. `dramas` - 剧目管理
2. `episodes` - 集数管理
3. `tasks` - 任务管理
4. `storyboards` - 分镜管理
5. `scenes` - 场景管理
6. `videos` - 视频生成和管理
7. `images` - 图片生成和管理
8. `audio` - 音频管理
9. `assets` - 资产管理
10. `character_library` - 角色库
11. `script_generation` - 剧本生成
12. `ai_configs` - AI 配置
13. `settings` - 系统设置

### 决策 3：渐进式迁移策略

**选择：** 逐步迁移模块，而非一次性重写

**理由：**
- 降低风险，每次迁移可以独立验证
- 可以在迁移过程中继续开发和修复 bug
- 便于回滚（如果某个模块迁移出现问题）

**迁移顺序：**
1. 先迁移较小的、依赖较少的模块（如 health, settings）
2. 再迁移核心业务模块（如 dramas, episodes）
3. 最后迁移复杂的、依赖多的模块（如 videos, storyboards）

### 决策 4：使用 FastAPI 内置依赖系统

**选择：** 不引入额外的依赖注入框架，使用 FastAPI 的 Depends

**理由：**
- FastAPI 的依赖系统已经足够强大
- 减少第三方依赖
- 更符合 FastAPI 生态
- 学习曲线平缓

### 决策 5：测试使用 httpx 异步客户端

**选择：** 配置异步测试客户端

**理由：**
- FastAPI 是异步框架，测试也应使用异步
- 避免事件循环问题
- 更准确地模拟生产环境

### 决策 6：配置分层组织

**选择：** requirements 分为 base.txt, dev.txt, prod.txt

**理由：**
- 开发和生产环境依赖分离
- 清晰的依赖关系
- 便于部署优化（生产环境不需要开发工具）

### 决策 7：统一 API 响应格式

**选择：** 所有接口返回统一的 `ApiResponse[T]` 格式

**理由：**
- 统一的响应格式便于前端处理
- 清晰的错误信息传递
- 符合国内 API 设计习惯
- 便于接口文档生成

**响应格式：**
```json
{
    "code": 200,
    "message": "success",
    "data": {...}
}
```

**实现方式：**
- 创建 `src/schemas.py` 定义 `ApiResponse` 泛型模型
- 创建 `ResponseCode` 类定义标准响应码
- 所有路由的 `response_model` 必须使用 `ApiResponse`
- 提供 `success()` 和 `error()` 类方法简化使用

### 决策 8：仅使用 GET 和 POST 方法

**选择：** 路由方法仅使用 GET（查询）和 POST（操作）

**理由：**
- 简化前端调用复杂度
- 避免浏览器/代理对某些方法的限制
- 操作类型由路径而非 HTTP 方法表示
- 符合国内 API 设计习惯

**路由命名规范：**
- 查询操作：`GET /模块/info`, `GET /模块/list`
- 创建操作：`POST /模块/create`
- 更新操作：`POST /模块/update`
- 删除操作：`POST /模块/delete`

### 决策 9：统一异常处理机制

**选择：** 使用自定义异常类 + 全局异常处理器

**理由：**
- 异常处理逻辑集中，便于维护
- 自动转换为 ApiResponse 格式
- 业务异常和系统异常分离
- 便于添加日志和监控

**异常类型：**
- `BusinessValidationException` - 业务参数验证失败
- `HttpClientException` - 第三方 API 调用失败
- 模块特定异常（如 `DramaNotFound`）- 继承自基础异常

### 决策 10：标准化接口文档

**选择：** 强制要求所有接口添加 summary 和 description

**理由：**
- 自动生成高质量的 OpenAPI 文档
- 便于团队协作和接口维护
- 提升开发体验

**文档要求：**
- 所有路由添加 `summary="简短描述"`
- 函数使用 docstring 描述详细行为
- 参数和返回值必须添加文档

## Risks / Trade-offs

### 风险 1：导入路径大量变更

**风险：** 所有 Python 文件的导入语句需要更新

**缓解措施：**
- 使用 IDE 的重构工具批量更新
- 编写迁移脚本辅助
- 在迁移过程中保持旧的导入路径临时可用（通过重新导出）

### 风险 2：循环依赖

**风险：** 模块间可能存在隐式的循环依赖

**缓解措施：**
- 明确模块依赖关系图
- 引入依赖时遵循单向依赖原则
- 如发现循环依赖，重新设计模块边界或提取共享模块

### 风险 3：API 响应格式破坏性变更

**风险：** 所有 API 响应格式改变，前端需要大量适配

**缓解措施：**
- 提前与前端团队沟通新的响应格式
- 提供响应格式过渡期（可能需要版本适配层）
- 编写清晰的 API 迁移文档
- 分阶段迁移接口，避免一次性全部改动

### 风险 4：路由方法变更影响

**风险：** 将 PUT/DELETE 改为 POST 可能影响 RESTful 纯粹主义者

**缓解措施：**
- 这是项目规范决策，符合国内 API 设计习惯
- 在文档中明确说明设计理念
- 确保路由命名清晰表达操作意图

### 风险 5：迁移过程中的服务中断

**风险：** 迁移过程中可能引入 bug

**缓解措施：**
- 每个模块迁移后立即运行完整测试
- 使用特性开关控制新旧代码切换
- 保持完整的测试覆盖率
- 准备快速回滚方案

### 风险 6：团队适应新规范

**风险：** 团队成员需要时间适应新的代码组织和 API 规范

**缓解措施：**
- 提供清晰的文档说明新结构和规范
- 进行团队培训
- 在代码审查中强化新规范
- 提供代码示例和模板

## Migration Plan

### 阶段 0：API 规范基础设施（优先级最高）

**在迁移任何模块之前，先完成 API 规范基础设施：**

1. 创建 `src/schemas.py` - 定义 ApiResponse 和 ResponseCode
2. 创建 `src/exceptions.py` - 定义自定义异常类
3. 创建 `src/exception_handlers.py` - 定义全局异常处理器
4. 更新 `src/main.py` - 注册所有异常处理器
5. 编写 API 规范文档和示例代码
6. 与前端团队同步新的 API 响应格式

### 阶段 1：准备工作（不破坏现有功能）

1. 创建新的目录结构骨架
2. 配置开发工具支持新的导入路径
3. 设置测试基础设施
4. **准备 API 响应格式适配层（如需要）**

### 阶段 2：渐进式迁移

按以下顺序逐个迁移模块：

**第一批（简单模块）：**
1. `health` - 健康检查（无依赖）
2. `settings` - 系统设置（依赖少）

**第二批（核心模块）：**
3. `ai_configs` - AI 配置
4. `character_library` - 角色库
5. `assets` - 资产管理

**第三批（业务模块）：**
6. `dramas` - 剧目
7. `episodes` - 集数
8. `scenes` - 场景

**第四批（复杂模块）：**
9. `tasks` - 任务
10. `storyboards` - 分镜
11. `script_generation` - 剧本生成

**第五批（媒体模块）：**
12. `images` - 图片
13. `audio` - 音频
14. `videos` - 视频
15. `video_merges` - 视频合并
16. `upload` - 上传

### 阶段 3：清理工作

1. 删除旧的 `app/` 目录
2. 更新所有文档
3. 更新部署配置

### 回滚策略

如果某个模块迁移出现问题：
1. 暂停该模块的迁移
2. 恢复该模块到旧结构
3. 修复问题后继续迁移
4. 其他已迁移模块不受影响

## Open Questions

1. **是否需要在迁移过程中保持 API 兼容性？**
   - 假设是，外部 API 行为不应改变

2. **数据库连接配置如何处理？**
   - 全局配置保留在 `src/database.py`
   - 各模块通过依赖获取数据库会话

3. **共享的 utility 函数放在哪里？**
   - 确实跨模块通用的放在 `src/utils/`
   - 模块特定的放在各模块的 `utils.py`

4. **是否需要引入 Alembic 进行数据库迁移？**
   - 当前项目已有数据库，但未使用 Alembic
   - 建议作为后续改进，不在本次重构范围内
